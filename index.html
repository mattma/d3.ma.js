<!doctype html>
<html lang="en">
<head>
		<meta charset="UTF-8">
		<title>D3 Test</title>
		<script type="text/javascript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
		<script src="libs/d3.v3.js"></script>
		<script src="libs/d3.chart.js"></script>

		<script src="src/common/container.js"></script>
		<style>
		svg {
			font: 10px sans-serif;
		}
		.line {
			fill: none; stroke: #000; stroke-width: 1.5px;
		}
		.axis path, .axis line {
			fill: none; stroke: #000; shape-rendering: crispEdges;
		}
		#vis {
			width: 1400px;
			height: 600px;
		}

		.guides .tick {
			stroke: lightgrey;
			opacity: 0.5;
		}
		.guides path {
			stroke-width: 0;
		}
		</style>
</head>
<body>
	 <div id="vis"></div>

	<script>
		// http://jsbin.com/isawar/4/edit

		/*
			internal, _xScale, _yScale are set dynamicially, after calling x() and y(), save the String representation of the current scale.
		 */
		d3.chart("GuideLine", {
			initialize: function() {
			      this.width = this.base.attr('width');
				this.height = this.base.attr('height');

				var self = this;

				this._x = (this._x) ? this._x : 'linear';
				this._y = (this._y) ? this._y : 'linear';

				this.xScale = this.x(this._x, true)._xScale;
				this.yScale = this.y(this._y, true)._yScale;

			     	this.on('xscale', function(scale){
			     		self.xScale = self._scale(scale);
			     	});

			     	this.on('yscale', function(scale){
			     		self.yScale = self._scale(scale);
			     	});
			},

			render: function() {
			     	// After this.xScale is being called, it will auto set the this._xScale variable
			     	// console.log(this._xScale);
			      this.xScale.rangeRoundBands([0, this.width], 0.1);

			      this.yScale.range([this.height, 0]);

				this.xAxis = d3.svg.axis().scale(this.xScale).orient("bottom");

				this.yAxis = d3.svg.axis().scale(this.yScale)
								.orient("left")
								.tickFormat(d3.format(',.1f'));

        		      this.xAxisG =  this.base.append('g').attr({
			            'class': 'x axis',
			            'transform': 'translate(0,' + this.height + ')'
			      });

			      this.yAxisG = this.base.append('g').attr({
			            'class': 'y axis'
			      });

				this.xGuide = this.base.append("g")
					.attr("class", "guides")
					.attr("transform", "translate(0," + this.height + ")");

				//The last thing that is included in the code to draw the grid lines is the instruction to suppress printing any label for the ticks;
				this.yGuide = this.base.append("g")
					.attr("class", "guides");

				// create a labels layer
				this.layer("guidline", this.base, {
					dataBind: function(data) {
						var chart = this.chart();

						chart.xScale.domain(d3.merge(data).map(function(d) { return d.label }));

					      var maxY = Math.round( d3.max( data.map(function(val, ind){ return val.value;  }) ) );
					      chart.yScale.domain([ 0, maxY ]);

						return this.selectAll('g').data(data);
					},

					insert: function(){
						return this.append('g');
					},

					events: {
						"enter": function() {
							var chart = this.chart();
							chart.xAxisG.call( chart.xAxis);
							chart.yAxisG.call( chart.yAxis);
						}
					}
				});
			},

			x: function(scale, internal) {
				if (arguments.length === 0) { return this._xScale; }
				this._x = scale;

				// Concept of 2nd arg, internal.
				// By default, it is false, called trigger when called from outside of module, it will auto
				// call the trigger scale for you. But when use in the internal module, it won't call any
				// trigger scale function since it will set it by default for you
				(internal) ? this._xScale = this._scale(scale) : this.trigger('xscale', scale);
				return this;
			},

			y: function(scale, internal) {
				if (arguments.length === 0) { return this._yScale; }

				this._y = scale;
				(internal) ? this._yScale = this._scale(scale) : this.trigger('yscale', scale);
				return this;
			},

			drawGuides: function() {

				this.xGuide.call(
					this.xAxis
						.tickSize(-this.height, 0, 0)
						.tickFormat('')
				);
				//axis.tickSize([major[â€‹[, minor], end]])

				this.yGuide.call(
					this.yAxis
						.tickSize(-this.width, 0, 0)
						.tickFormat('')
				);

				return this;
			},

			_scale: function(scale) {
				switch(scale) {
					case 'linear':
						return d3.scale.linear();
					break;

					case 'ordinal':
						return d3.scale.ordinal();
					break;

					default:
						return d3.scale.linear();
					break;
				}
			}
		});

		// define a new chart type: a circle chart
		d3.chart("BarChart", {

			initialize: function() {

			      var color = d3.scale.category10();

     			      var width = this.base.attr('width'),
					height = this.base.attr('height');

			      this.yScale = d3.scale.linear()
			                                .range([height, 0]);

			      this.xScale = d3.scale.ordinal()
			                                .rangeRoundBands([0, width], 0.1);

			      var xAxis = d3.svg.axis().scale(this.xScale).orient("bottom");

			      var yAxis = d3.svg.axis().scale(this.yScale)
			                                .orient("left")
			                                .tickFormat(d3.format(',.1f'));

				// create a layer of circles that will go into
				// a new group element on the base of the chart
				this.layer("bars", this.base, {

					// select the elements we wish to bind to and
					// bind the data to them.
					dataBind: function(data) {
						var chart = this.chart();

						chart.xScale.domain(d3.merge(data).map(function(d) { return d.label }));

					      var maxY = Math.round( d3.max( data.map(function(val, ind){ return val.value;  }) ) );
					      chart.yScale.domain([ 0, maxY ]);

						return this.selectAll(".group")
							.data(data);
					},

					// insert actual bars
					insert: function() {
						return this.append('g').classed('group', true);
					},

					// define lifecycle events
					events: {

						// paint new elements, but set their radius to 0
						// and make them red
						"enter": function() {
							var chart = this.chart();

							this.append('rect').attr({
						            'x': function(d, i) { return chart.xScale(d.label); },
						            'y': function(d) { return chart.yScale(d.value); },
						            'width': function(d) { return chart.xScale.rangeBand() ; },
						            'height': function(d) { return height - chart.yScale(d.value); },
						            'fill': function(d) { return color(d.value); }
						        });
						}
						// // then transition them to a radius of 5 and change
						// // their fill to blue
						// "enter:transition": function() {
						// 	var chart = this.chart();
						// 	return this
						// 		.delay(500)
						// 		.attr("r", chart.radius())
						// 		.style("fill", "yellow");
						// }
					}
				});
			},
			width: function(newWidth) {
				if (arguments.length === 0) {
						return this._width;
				}
				this._width = newWidth;
				this.base.attr("width", this._width);
				this.xScale.range([0, this._width]);
				return this;
			}
		});

		d3.chart("LabeledCirclesChart", {
			initialize: function() {

				var guideLineG = this.base.append("g").classed('guideline', true).attr({
					'width': this.base.attr('width'),
					'height': this.base.attr('height')
				});

				var barsG = this.base.append("g").classed('bars', true).attr({
					'width': this.base.attr('width'),
					'height': this.base.attr('height')
				});

				var axis =  this.mixin("GuideLine",  guideLineG);

				// .x() could be chained, here is just for a demo,
				// you have to call ordinal or any other to override the default behavior
				// otherwise, it would assume to be 'linear', then have to manually call render() fn
				// axis.render();
				axis.x('ordinal').y('linear').render();

				//Draw Guides here
				axis.layer("guidline").on("enter", function(t) {
					axis.drawGuides();
				});

				this.bars = this.mixin("BarChart", barsG);
			}
		});

		var container = d3.ma.container('#vis').box(1400,500);

		var canvas = container.canvas().chart("LabeledCirclesChart");

   var data = [
      {
        "label" : "A" ,
        "value" : 29.765957771107
      } ,
      {
        "label" : "B" ,
        "value" : 0
      } ,
      {
        "label" : "C" ,
        "value" : 32.807804682612
      } ,
      {
        "label" : "D" ,
        "value" : 196.45946739256
      } ,
      {
        "label" : "E" ,
        "value" : 0.19434030906893
      } ,
      {
        "label" : "F" ,
        "value" : 98.079782601442
      } ,
      {
        "label" : "G" ,
        "value" : 13.925743130903
      } ,
      {
        "label" : "H" ,
        "value" : 5.1387322875705
      }
    ];
		//render it with some data
		canvas.draw(data);

	</script>

	<!-- livereload snippet  -->
	<script src="http://localhost:35729/livereload.js?snipver=1"></script>
</body>
</html>
