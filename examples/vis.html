<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FTA DataVis</title>
  <style>
    .node {
      cursor: pointer;
    }

    .node circle {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 1.5px;
    }

    .node text {
      font: 14px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 1.5px;
    }

    /* = d3.ma.css Start from here = */
    .d3maTooltip-pending-removal {
      position: absolute;
      pointer-events: none;
    }

    .d3maTooltip {
      position: absolute;
      background-color: rgba(255, 255, 255, 0.85);
      min-width: 180px;
      padding: 7px 12px;
      overflow: hidden;
      text-align: center;
      border: 1px solid rgba(0, 0, 0, .2);
      z-index: 10000;

      font-family: Arial;
      font-size: 13px;
      -moz-box-shadow: 0 5px 10px rgba(0, 0, 0, .2);
      -webkit-box-shadow: 0 5px 10px rgba(0, 0, 0, .2);
      box-shadow: 0 5px 10px rgba(0, 0, 0, .2);

      -webkit-border-radius: 6px;
      -moz-border-radius: 6px;
      border-radius: 6px;

      pointer-events: none;

      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .label {
      text-anchor: middle;
      font-size: 1.4em;
      fill: black;
      font-family: arial, helvetica, sans-serif;
      text-transform: capitalize;
    }

    #vis {
      width: 1800px;
      height: 1000px;
    }

    svg {
      font: 14px sans-serif;
    }

    .dot {
      fill: white;
      stroke: steelblue;
      stroke-width: 1.5px;
    }

    .circles {
      stroke: steelblue;
    }

    p {
      margin: 0;
    }
  </style>

  <script src="../libs/d3.v3.js"></script>
  <script src="../libs/lodash.js"></script>
  <script src="../build/d3.ma.js"></script>
</head>
<body>
<div id="vis"></div>

<script>
  var i = 0;
  var container = d3.ma.container('#vis').margin({left: 50});
  container.box(1800, 1000);

  function setupTreeData (data, chart, context) {
    var info = context.info;
    var tree = d3.layout.tree()
      .size([info.canvasH, info.canvasW]);

    var nodes = tree.nodes(data).reverse();

    // Normalize for fixed-depth.
    nodes.forEach(function (d) {
      d.id = d.id || ++i;
      d.y = d.depth * 180;
    });

    var links = tree.links(nodes);

    // attach nodes to the context, so it could be reused
    // inside other methods like `onEnter`
    chart.nodes = nodes;

    return {
      nodes: nodes,
      links: links
    };
  }

  function stashOldPosition (context) {
    // Stash the old positions for transition.
    context.nodes.forEach(function (d) {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  function setupStartAnimationPoint (data, chart) {
    chart.curX = (data.clickedElement) ? data.clickedElement.x0 : data.x0;
    chart.curY = (data.clickedElement) ? data.clickedElement.y0 : data.y0;
  }

  function setLineStartLocation (chart, single, context) {
    var chart = chart || this;

    single.attr("d", function (d) {
      // from the center of the tree, animate to the point
      var originalPosition = {
        x: chart.curX,
        y: chart.curY
      };
      return chart.diagonal({
        source: originalPosition,
        target: originalPosition
      });
    });
  }

  function genJSON (csvData, groups) {
    var genGroups = function (data) {
      return _.map(data, function (element, index) {
        if (index !== null || index !== '#N/A' || index !== "" || index !== undefined) {
          //return {name: "Other", children: element};
          //else{
          return {name: index, children: element};
        }
      });
    };

    var nest = function (node, curIndex) {
      if (curIndex === 0) {
        node.children = genGroups(_.groupBy(csvData, groups[0]));
        _.each(node.children, function (child) {
          nest(child, curIndex + 1);
        });
      } else {
        if (curIndex < groups.length) {
          node.children = genGroups(
            _.groupBy(node.children, groups[curIndex])
          );
          _.each(node.children, function (child) {
            nest(child, curIndex + 1);
          });
        }
      }
      return node;
    };
    return nest({}, 0);
  }

  // Get JSON data
  d3.csv("/api/FundingData.csv", function (error, data) {
    var groups = ["FTA Region", "State", "Agency Type"];
    data = genJSON(data, groups);

    d3.chart('Tree').extend('MyTree', {
      onDataBind: function (data, chart) {
        var chart = chart || this;
        var dataSet = setupTreeData(data, chart, this);
        setupStartAnimationPoint(data, chart);
        return dataSet.nodes;
      },

      onInsert: function (chart, node) {
        var chart = chart || this;
        var height = chart.info.canvasH;

        // Enter any new nodes at the parent's previous position.
        // controlling animate the content from left to right
        node
          .attr("transform", function (d) {
            return "translate(" + chart.curY + "," + chart.curX + ")";
          })
          .on("click", click);
      },

      onEnter: function (chart, single) {
        var chart = chart || this;

        single.append("circle")
          .attr("r", 1e-6)
          .style("fill", function (d) {
            return d._children ? "lightsteelblue" : "#fff";
          });

        single.append("text")
          .attr("x", function (d) {
            return d.children || d._children ? -10 : 10;
          })
          .attr("dy", ".35em")
          .attr("text-anchor", function (d) {
            return d.children || d._children ? "end" : "start";
          })
          .text(function (d) {
            return d.name;
          })
          .style("fill-opacity", 1e-6);
      },

      onEnterTransition: function (chart, single) {
        var chart = chart || this;
        var duration = chart.options.animationDuration || 750;
        single
          .duration(duration)
          .attr("transform", function (d) {
            return "translate(" + d.y + "," + d.x + ")";
          });

        single.select("circle")
          .attr("r", 5)
          .style("fill", function (d) {
            return d._children ? "lightsteelblue" : "#fff";
          });

        single.select("text")
          .style("fill-opacity", 1);
      },

      onMerge: function (chart, single) {
        var chart = chart || this;
        single.select("circle")
          .style("fill", function (d) {
            return d._children ? "lightsteelblue" : "#fff";
          });

        stashOldPosition(chart);
      },

      onMergeTransition: function (chart, single) {
        var chart = chart || this;
        var duration = chart.options.animationDuration || 750;
        single
          .duration(duration)
          .attr("transform", function (d) {
            return "translate(" + d.y + "," + d.x + ")";
          });
      },

      onRemove: function (chart, single) {
        var chart = chart || this;

        single
          .duration(300)
          .ease('cubic-in-out')
          .attr("transform", function (d) {
            return "translate(" + chart.curY + "," + chart.curX + ")";
          })
          .remove();
      },

      onDataMouseenter: function (d, i, chart) {
        var chart = chart || this;
        var obj = {
          'label':      "Name: " + d.name,
          'value':      "showing some value",
          'state':      (d['State']) ? d['State'] : void 0,
          'operating':  (d['Operating']) ? d['Operating'] : void 0,
          'ftaRegion':  (d['FTA Region']) ? d['FTA Region'] : void 0,
          'capital':    (d['Capital']) ? d['Capital'] : void 0,
          'agencyType': (d['Agency Type']) ? d['Agency Type'] : void 0,
          'pointIndex': i,
          'd':          d,
          'event':      d3.event,
          'pos':        [d.y + 80, d.x + 20]
        };
        return obj;
      }
    });

    d3.chart('DiagonalLine').extend('ConnectPath', {
      onDataBind: function (data, chart) {
        var chart = chart || this;
        var dataSet = setupTreeData(data, chart, this);
        setupStartAnimationPoint(data, chart);
        return dataSet.links;
      },

      onInsert: function (chart, path) {
        var chart = chart || this;
        setLineStartLocation(chart, path, this);
      },

      onEnterTransition: function (chart, single) {
        var chart = chart || this;
        var duration = chart.options.animationDuration || 750;
        var easing = chart.options.animationEasing || 'cubic-in-out';

        single
          .duration(duration)
          .ease(easing)
          .attr({'d': chart.diagonal});
      },

      onMerge: function (chart, single) {
        var chart = chart || this;
        stashOldPosition(chart);
      },

      onMergeTransition: function (chart, single) {
        var chart = chart || this;
        var duration = chart.options.animationDuration || 750;
        var easing = chart.options.animationEasing || 'cubic-in-out';

        single
          .duration(duration)
          .ease(easing)
          .attr({'d': chart.diagonal});
      },

      onRemove: function (chart, single) {
        var chart = chart || this;

        single
          .duration(300)
          .ease('cubic-in-out')
          .attr("d", function (d) {
            var o = {x: chart.curX, y: chart.curY};
            return chart.diagonal({source: o, target: o});
          })
          .remove();
      }
    });

    d3.chart("FinalChart", {
      initialize: function (containerInfo) {
        this.mixin("ConnectPath", this.base.append('g').classed('path', true), {
          info:              containerInfo,
          animationDuration: 750
        });

        var tree = this.mixin("MyTree", this.base.append('g').classed('tree', true), {
          info:              containerInfo,
          animationDuration: 750
        });

        // Tooltip section
        var tooltip = d3.ma.tooltip(this.base);
        tree.dispatch.on('d3maMouseenter', function (e) {
          var html = "<div class='tips'>" +
            e.label + "<br> <p>" + e.value + "</p>";

          html += (e.state) ? "<br> <p> State: <strong>" + e.state + "</strong></p>" : '';
          html += (e.operating) ? "<br> <p> Operating: <strong>" + e.operating + "</strong></p>" : '';
          html += (e.ftaRegion) ? "<br> <p> FTA Region: <strong>" + e.ftaRegion + "</strong></p>" : '';
          html += (e.capital) ? "<br><p> Capital: <strong>" + e.capital + "</strong></p>" : '';
          html += (e.agencyType) ? "<br> <p> Agency Type: <strong>" + e.agencyType + "</strong></p>" : '';

          var closeHTML = "</div>";
          html += closeHTML;
          tooltip.show([e.pos[0], e.pos[1]], html);
        });

        tree.dispatch.on('d3maMouseout', function (e) {
          tooltip.close();
        });
      }
    });

    data.children = swapChildren(data.children);

    data.x0 = container.info().canvasH / 2;
    data.y0 = 0;

    var canvas = container.canvas().chart("FinalChart", container.info());
    canvas.draw(data);

    // recursive replace the children nodes to show its elements
    function swapChildren (arr, d) {
      return d3.ma.map(arr, function (eachD) {
        // initial loading does not contain "d" argument
        // "d" should be fulfilled when user clicked on a node
        if (!d) {
          if (eachD.children) {
            eachD._children = eachD.children;
            eachD.children = null;
            // recursive calling its children to collapse its children
            swapChildren(eachD._children);
          }
        } else {
          // Only manipulate the clicked on node, ignore the non-clicked nodes
          // but sometimes it could be the children of "eachD", check in "else" statement
          if (d.name === eachD.name) {
            if (d._children) {
              // should expand the tree
              if (eachD.name === d.name) {
                if (eachD._children) {
                  eachD.children = eachD._children;
                  eachD._children = null;
                }
              } else if (eachD.name === d.parent.name) {
                swapChildren(eachD.children, d);
              }
            } else if (d.children) {
              // should collapse the tree
              eachD._children = eachD.children;
              eachD.children = null;
            }
          } else {
            // if the "eachD" is already expanded, so we need to check
            // its children to see if it is the children of the "eachD"'s children
            if (eachD.children) {
              swapChildren(eachD.children, d);
            }
          }
        }
        return eachD;
      });
    }

    // Toggle children on click.
    function click (d) {
      var clickedElement = {
        name: d.name,
        x0:   d.x0,
        y0:   d.y0
      };
      data['clickedElement'] = clickedElement;

      data.children = swapChildren(data.children, d);

      canvas.draw(data);
    }
  });
</script>
</body>
</html>
